// Code generated by go-bindata.
// sources:
// static/dashboard.css
// static/dashboard.html
// static/dashboard.js
// static/include/Orbitron700.ttf
// static/include/Orbitron700.woff
// static/include/base.css
// static/include/base64.js
// static/include/black.css
// static/include/blue.css
// static/include/chrome-app/tcp-client.js
// static/include/des.js
// static/include/display.js
// static/include/inflator.js
// static/include/input.js
// static/include/keyboard.js
// static/include/keysym.js
// static/include/keysymdef.js
// static/include/logo.js
// static/include/playback.js
// static/include/rfb.js
// static/include/ui.js
// static/include/util.js
// static/include/websock.js
// static/include/webutil.js
// static/vnc_auto.html
// DO NOT EDIT!

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

// bindataRead reads the given file from disk. It returns an error on failure.
func bindataRead(path, name string) ([]byte, error) {
	buf, err := ioutil.ReadFile(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset %s at %s: %v", name, path, err)
	}
	return buf, err
}

type asset struct {
	bytes []byte
	info  os.FileInfo
}

// dashboardCss reads file data from disk. It returns an error on failure.
func dashboardCss() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/dashboard.css"
	name := "dashboard.css"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// dashboardHtml reads file data from disk. It returns an error on failure.
func dashboardHtml() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/dashboard.html"
	name := "dashboard.html"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// dashboardJs reads file data from disk. It returns an error on failure.
func dashboardJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/dashboard.js"
	name := "dashboard.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeOrbitron700Ttf reads file data from disk. It returns an error on failure.
func includeOrbitron700Ttf() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/Orbitron700.ttf"
	name := "include/Orbitron700.ttf"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeOrbitron700Woff reads file data from disk. It returns an error on failure.
func includeOrbitron700Woff() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/Orbitron700.woff"
	name := "include/Orbitron700.woff"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeBaseCss reads file data from disk. It returns an error on failure.
func includeBaseCss() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/base.css"
	name := "include/base.css"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeBase64Js reads file data from disk. It returns an error on failure.
func includeBase64Js() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/base64.js"
	name := "include/base64.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeBlackCss reads file data from disk. It returns an error on failure.
func includeBlackCss() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/black.css"
	name := "include/black.css"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeBlueCss reads file data from disk. It returns an error on failure.
func includeBlueCss() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/blue.css"
	name := "include/blue.css"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeChromeAppTcpClientJs reads file data from disk. It returns an error on failure.
func includeChromeAppTcpClientJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/chrome-app/tcp-client.js"
	name := "include/chrome-app/tcp-client.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeDesJs reads file data from disk. It returns an error on failure.
func includeDesJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/des.js"
	name := "include/des.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeDisplayJs reads file data from disk. It returns an error on failure.
func includeDisplayJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/display.js"
	name := "include/display.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeInflatorJs reads file data from disk. It returns an error on failure.
func includeInflatorJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/inflator.js"
	name := "include/inflator.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeInputJs reads file data from disk. It returns an error on failure.
func includeInputJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/input.js"
	name := "include/input.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeKeyboardJs reads file data from disk. It returns an error on failure.
func includeKeyboardJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/keyboard.js"
	name := "include/keyboard.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeKeysymJs reads file data from disk. It returns an error on failure.
func includeKeysymJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/keysym.js"
	name := "include/keysym.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeKeysymdefJs reads file data from disk. It returns an error on failure.
func includeKeysymdefJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/keysymdef.js"
	name := "include/keysymdef.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeLogoJs reads file data from disk. It returns an error on failure.
func includeLogoJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/logo.js"
	name := "include/logo.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includePlaybackJs reads file data from disk. It returns an error on failure.
func includePlaybackJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/playback.js"
	name := "include/playback.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeRfbJs reads file data from disk. It returns an error on failure.
func includeRfbJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/rfb.js"
	name := "include/rfb.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeUiJs reads file data from disk. It returns an error on failure.
func includeUiJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/ui.js"
	name := "include/ui.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeUtilJs reads file data from disk. It returns an error on failure.
func includeUtilJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/util.js"
	name := "include/util.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeWebsockJs reads file data from disk. It returns an error on failure.
func includeWebsockJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/websock.js"
	name := "include/websock.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// includeWebutilJs reads file data from disk. It returns an error on failure.
func includeWebutilJs() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/include/webutil.js"
	name := "include/webutil.js"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// vnc_autoHtml reads file data from disk. It returns an error on failure.
func vnc_autoHtml() (*asset, error) {
	path := "/home/will/src/go/src/github.com/wrouesnel/vncdashboard/static/vnc_auto.html"
	name := "vnc_auto.html"
	bytes, err := bindataRead(path, name)
	if err != nil {
		return nil, err
	}

	fi, err := os.Stat(path)
	if err != nil {
		err = fmt.Errorf("Error reading asset info %s at %s: %v", name, path, err)
	}

	a := &asset{bytes: bytes, info: fi}
	return a, err
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("Asset %s can't read by error: %v", name, err)
		}
		return a.bytes, nil
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// MustAsset is like Asset but panics when Asset would return an error.
// It simplifies safe initialization of global variables.
func MustAsset(name string) []byte {
	a, err := Asset(name)
	if err != nil {
		panic("asset: Asset(" + name + "): " + err.Error())
	}

	return a
}

// AssetInfo loads and returns the asset info for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func AssetInfo(name string) (os.FileInfo, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		a, err := f()
		if err != nil {
			return nil, fmt.Errorf("AssetInfo %s can't read by error: %v", name, err)
		}
		return a.info, nil
	}
	return nil, fmt.Errorf("AssetInfo %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() (*asset, error){
	"dashboard.css": dashboardCss,
	"dashboard.html": dashboardHtml,
	"dashboard.js": dashboardJs,
	"include/Orbitron700.ttf": includeOrbitron700Ttf,
	"include/Orbitron700.woff": includeOrbitron700Woff,
	"include/base.css": includeBaseCss,
	"include/base64.js": includeBase64Js,
	"include/black.css": includeBlackCss,
	"include/blue.css": includeBlueCss,
	"include/chrome-app/tcp-client.js": includeChromeAppTcpClientJs,
	"include/des.js": includeDesJs,
	"include/display.js": includeDisplayJs,
	"include/inflator.js": includeInflatorJs,
	"include/input.js": includeInputJs,
	"include/keyboard.js": includeKeyboardJs,
	"include/keysym.js": includeKeysymJs,
	"include/keysymdef.js": includeKeysymdefJs,
	"include/logo.js": includeLogoJs,
	"include/playback.js": includePlaybackJs,
	"include/rfb.js": includeRfbJs,
	"include/ui.js": includeUiJs,
	"include/util.js": includeUtilJs,
	"include/websock.js": includeWebsockJs,
	"include/webutil.js": includeWebutilJs,
	"vnc_auto.html": vnc_autoHtml,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for childName := range node.Children {
		rv = append(rv, childName)
	}
	return rv, nil
}

type bintree struct {
	Func     func() (*asset, error)
	Children map[string]*bintree
}
var _bintree = &bintree{nil, map[string]*bintree{
	"dashboard.css": &bintree{dashboardCss, map[string]*bintree{}},
	"dashboard.html": &bintree{dashboardHtml, map[string]*bintree{}},
	"dashboard.js": &bintree{dashboardJs, map[string]*bintree{}},
	"include": &bintree{nil, map[string]*bintree{
		"Orbitron700.ttf": &bintree{includeOrbitron700Ttf, map[string]*bintree{}},
		"Orbitron700.woff": &bintree{includeOrbitron700Woff, map[string]*bintree{}},
		"base.css": &bintree{includeBaseCss, map[string]*bintree{}},
		"base64.js": &bintree{includeBase64Js, map[string]*bintree{}},
		"black.css": &bintree{includeBlackCss, map[string]*bintree{}},
		"blue.css": &bintree{includeBlueCss, map[string]*bintree{}},
		"chrome-app": &bintree{nil, map[string]*bintree{
			"tcp-client.js": &bintree{includeChromeAppTcpClientJs, map[string]*bintree{}},
		}},
		"des.js": &bintree{includeDesJs, map[string]*bintree{}},
		"display.js": &bintree{includeDisplayJs, map[string]*bintree{}},
		"inflator.js": &bintree{includeInflatorJs, map[string]*bintree{}},
		"input.js": &bintree{includeInputJs, map[string]*bintree{}},
		"keyboard.js": &bintree{includeKeyboardJs, map[string]*bintree{}},
		"keysym.js": &bintree{includeKeysymJs, map[string]*bintree{}},
		"keysymdef.js": &bintree{includeKeysymdefJs, map[string]*bintree{}},
		"logo.js": &bintree{includeLogoJs, map[string]*bintree{}},
		"playback.js": &bintree{includePlaybackJs, map[string]*bintree{}},
		"rfb.js": &bintree{includeRfbJs, map[string]*bintree{}},
		"ui.js": &bintree{includeUiJs, map[string]*bintree{}},
		"util.js": &bintree{includeUtilJs, map[string]*bintree{}},
		"websock.js": &bintree{includeWebsockJs, map[string]*bintree{}},
		"webutil.js": &bintree{includeWebutilJs, map[string]*bintree{}},
	}},
	"vnc_auto.html": &bintree{vnc_autoHtml, map[string]*bintree{}},
}}

// RestoreAsset restores an asset under the given directory
func RestoreAsset(dir, name string) error {
	data, err := Asset(name)
	if err != nil {
		return err
	}
	info, err := AssetInfo(name)
	if err != nil {
		return err
	}
	err = os.MkdirAll(_filePath(dir, filepath.Dir(name)), os.FileMode(0755))
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(_filePath(dir, name), data, info.Mode())
	if err != nil {
		return err
	}
	err = os.Chtimes(_filePath(dir, name), info.ModTime(), info.ModTime())
	if err != nil {
		return err
	}
	return nil
}

// RestoreAssets restores an asset under the given directory recursively
func RestoreAssets(dir, name string) error {
	children, err := AssetDir(name)
	// File
	if err != nil {
		return RestoreAsset(dir, name)
	}
	// Dir
	for _, child := range children {
		err = RestoreAssets(dir, filepath.Join(name, child))
		if err != nil {
			return err
		}
	}
	return nil
}

func _filePath(dir, name string) string {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	return filepath.Join(append([]string{dir}, strings.Split(cannonicalName, "/")...)...)
}

